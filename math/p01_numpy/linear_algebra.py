#!/usr/bin/env python
# -*- coding: utf-8 -*-
'''
@Author: Ulysses
@Date: 2019-11-04 09:47:51
@Description: 线性代数相关
@LastEditTime: 2019-11-04 11:35:19
'''
import numpy as np
"""
1. dot 两个数组的点积
2. vdot 两个向量的点积
3. inner 两个数组的内积
4. matmul 两个数组的矩阵积
5. determinant 数组的行列式
6. solve 求解线性矩阵方程
7. inv 寻找矩阵的乘法逆矩阵
"""

# dot 点积 对于二维向量，其等效于矩阵乘法
# 对于 N 维数组，它是a的最后一个轴上的和与b的倒数第二个轴的乘积。
# cij = ∑aitbtj  [[1*11+2*13, 1*12+2*14],[3*11+4*13, 3*12+4*14]]
a = np.array([[1, 2], [3, 4]])
b = np.array([[11, 12], [13, 14]])
print("点积\n", np.dot(a, b))
"""
 [[37 40]
 [85 92]]
"""

# vdot 返回2个向量的积
print(np.vdot(a, b))  # 130
# 1*11 + 2*12 + 3*13 + 4*14

# inner 一维数组的向量内积。 对于更高的维度，它返回最后一个轴上的和的乘积
print(np.inner(np.array([1, 2, 3]), np.array([0, 1, 0])))  # 2
# 1*0 + 2*1 + 3*0

print('多维数组内积\n', np.inner(a, b))
"""
 [[35 41]
 [81 95]]
"""
# 1*11+2*12, 1*13+2*14
# 3*11+4*12, 3*13+4*14


# matmul
"""
numpy.matmul() 函数返回两个数组的矩阵乘积。 虽然它返回二维数组的正常乘
积，但如果任一参数的维数大于2，则将其视为存在于最后两个索引的矩阵的栈，
并进行相应广播。
另一方面，如果任一参数是一维数组，则通过在其维度上附加 1 来将其提升为矩
阵，并在乘法之后被去除
"""
a = [[1, 0], [0, 1]]
b = [[4, 1], [2, 2]]
# 二维数组 矩阵乘积
print("matmul矩阵乘积:\n", np.matmul(a, b))
"""
 [[4 1]
 [2 2]]
"""
b = [1, 2]
print("二维和一维\n", np.matmul(a, b))
print("一维和二维\n", np.matmul(b, a))
"""
二维和一维
 [1 2]
一维和二维
 [1 2]
"""
# 维度大于2
a = np.arange(8).reshape(2, 2, 2)
b = np.arange(4).reshape(2, 2)
print("三维 二维\n", np.matmul(a, b))
"""
 [[[ 2  3]
  [ 6 11]]

 [[10 19]
  [14 27]]]
"""

# 行列式 linalg.det 它从方阵的对角元素计算。 对于 2×2 矩阵，
# 它是左上和右下元素的乘积与其他两个的乘积的差
# [[a, b], [c, d]] ->　ad-bc
a = np.array([[1, 2], [3, 4]], dtype='i1')
print(np.linalg.det(a))
# -2.0000000000000004

b = np.arange(1, 10).reshape(3, 3)
print(b)
"""
[[1 2 3]
 [4 5 6]
 [7 8 9]]
"""
print(np.linalg.det(b))  # 0.0
# 1*(5*9-6*7)-2*(4*9-6*7)+3*(4*8-5*7) = 0


# linalg.solve  矩阵形式的线性方程的解
# x + y + z = 6
# 2y + 5z = -4
# 2x + 5y - z = 27
# 矩阵表示
#  1 1 1   x     6
#  0 2 5   y  = -4
#  2 5 -1  z     27
# AX = B  -> X = A^(-1)B

# 矩阵的逆  A*A^(-1) = I  linalg.inv
x = np.array([[1, 2], [3, 4]])
y = np.linalg.inv(x)
print("矩阵的逆:\n", y)
print(np.dot(x, y))
"""
 [[-2.   1. ]
 [ 1.5 -0.5]]
[[1.0000000e+00 0.0000000e+00]
 [8.8817842e-16 1.0000000e+00]]
"""

# 求线性方程的解
a = np.array([[1, 1, 1], [0, 2, 5], [2, 5, -1]])
b = np.array([[6], [-4], [27]])
print("方程的解:\n", np.linalg.solve(a, b))
"""
 [[ 5.]
 [ 3.]
 [-2.]]
"""
print("利用X=A^(-1)B求解:\n", np.dot(np.linalg.inv(a), b))
"""
 [[ 5.]
 [ 3.]
 [-2.]]
"""
